# Phase 5: UPS-RS Tasks 5-9 - Implementation Plan

> **For Claude:** Continuation of Phase 5 UPS-RS implementation. Tasks 1-4 complete.

**Goal:** Complete UPS-RS Worklist Service with update, state changes, cancellation, search, and subscription stubs.

**Architecture:** Extends Tasks 1-4 with remaining CRUD operations, state transitions, and search capabilities.

**Tech Stack:** Python 3.12, FastAPI, SQLAlchemy async, PostgreSQL

---

## Task 5: Update Workitem Endpoint

**Goal:** Implement PUT endpoint for updating workitem attributes with transaction UID validation.

**Files:**
- Modify: `app/routers/ups.py`
- Create: `tests/test_ups_update.py`

### Requirements

1. **Endpoint:** `PUT /v2/workitems/{workitem_uid}`
2. **Validation:**
   - Workitem must exist (404 if not)
   - Cannot update COMPLETED/CANCELED workitems (400)
   - SCHEDULED workitems: No transaction UID required
   - IN PROGRESS workitems: Transaction UID required and must match
3. **Update Rules:**
   - Merge provided DICOM attributes with existing dataset
   - Cannot change SOP Instance UID (00080018)
   - Cannot change ProcedureStepState via update (use state change endpoint)
   - Cannot add/change Transaction UID (00081195)
4. **Response:**
   - 200 OK on success (empty body)
   - 400 Bad Request for invalid updates
   - 409 Conflict if transaction UID doesn't match

### Implementation

```python
@router.put(
    "/v2/workitems/{workitem_uid}",
    status_code=200,
    summary="Update workitem (UPS-RS)",
)
async def update_workitem(
    workitem_uid: str,
    request: Request,
    db: AsyncSession = Depends(get_db),
):
    """
    Update UPS workitem attributes.

    Transaction UID required for IN PROGRESS workitems.
    Cannot update COMPLETED/CANCELED workitems.

    Returns:
    - 200 OK on success
    - 400 Bad Request if invalid update
    - 404 Not Found if workitem doesn't exist
    - 409 Conflict if transaction UID doesn't match
    """
    payload = await request.json()

    # Get workitem
    result = await db.execute(
        select(Workitem).where(Workitem.sop_instance_uid == workitem_uid)
    )
    workitem = result.scalar_one_or_none()

    if not workitem:
        raise HTTPException(
            status_code=404,
            detail=f"Workitem {workitem_uid} not found"
        )

    # Validate cannot change SOP Instance UID
    if "00080018" in payload:
        sop_value = payload["00080018"].get("Value", [])
        if sop_value and sop_value[0] != workitem_uid:
            raise HTTPException(
                status_code=400,
                detail="Cannot change SOP Instance UID"
            )

    # Validate cannot change state via update
    if "00741000" in payload:
        raise HTTPException(
            status_code=400,
            detail="Use state change endpoint to modify ProcedureStepState"
        )

    # Validate cannot add/change transaction UID
    if "00081195" in payload:
        raise HTTPException(
            status_code=400,
            detail="Cannot modify Transaction UID"
        )

    # Extract transaction UID from request header
    txn_uid = request.headers.get("Transaction-UID")

    # Check if update is allowed (uses state machine)
    from app.services.ups_state_machine import can_update_workitem, StateTransitionError

    try:
        can_update_workitem(
            current_state=workitem.procedure_step_state,
            current_txn_uid=workitem.transaction_uid,
            provided_txn_uid=txn_uid
        )
    except StateTransitionError as e:
        raise HTTPException(status_code=409, detail=str(e))

    # Merge updates into dataset
    updated_dataset = workitem.dicom_dataset.copy()
    updated_dataset.update(payload)

    # Re-extract searchable attributes
    patient_name = None
    patient_id = None

    patient_name_tag = updated_dataset.get("00100010", {})
    if patient_name_tag.get("Value"):
        pn_value = patient_name_tag["Value"][0]
        if isinstance(pn_value, dict):
            patient_name = pn_value.get("Alphabetic", "")
        else:
            patient_name = str(pn_value)

    patient_id_tag = updated_dataset.get("00100020", {})
    patient_id_values = patient_id_tag.get("Value", [])
    if patient_id_values:
        patient_id = patient_id_values[0]

    # Update workitem
    workitem.dicom_dataset = updated_dataset
    workitem.patient_name = patient_name
    workitem.patient_id = patient_id

    await db.commit()

    return Response(status_code=200)
```

### Tests

```python
def test_update_scheduled_workitem(client: TestClient):
    """Update SCHEDULED workitem without transaction UID."""
    # Create workitem
    workitem_uid = "1.2.3.4.5"
    payload = {
        "00080018": {"vr": "UI", "Value": [workitem_uid]},
        "00741000": {"vr": "CS", "Value": ["SCHEDULED"]},
    }
    client.post(f"/v2/workitems?{workitem_uid}", json=payload)

    # Update workitem
    update = {
        "00100010": {"vr": "PN", "Value": [{"Alphabetic": "Smith^Jane"}]}
    }
    response = client.put(f"/v2/workitems/{workitem_uid}", json=update)

    assert response.status_code == 200


def test_update_in_progress_requires_txn_uid(client: TestClient):
    """Update IN PROGRESS workitem requires transaction UID."""
    # Create and claim workitem
    workitem_uid = "1.2.3.4.5"
    # ... create and claim ...

    # Try to update without transaction UID
    update = {"00100010": {"vr": "PN", "Value": [{"Alphabetic": "Smith^Jane"}]}}
    response = client.put(f"/v2/workitems/{workitem_uid}", json=update)

    assert response.status_code == 409


def test_cannot_update_completed_workitem(client: TestClient):
    """Cannot update COMPLETED workitem."""
    # Create, claim, and complete workitem
    # ...

    # Try to update
    update = {"00100010": {"vr": "PN", "Value": [{"Alphabetic": "Smith^Jane"}]}}
    response = client.put(f"/v2/workitems/{workitem_uid}", json=update)

    assert response.status_code == 400
```

---

## Task 6: Change State Endpoint

**Goal:** Implement PUT endpoint for changing workitem state with state machine enforcement.

**Files:**
- Modify: `app/routers/ups.py`
- Create: `tests/test_ups_state.py`

### Requirements

1. **Endpoint:** `PUT /v2/workitems/{workitem_uid}/state`
2. **Request Body:**
   ```json
   {
     "00741000": {"vr": "CS", "Value": ["IN PROGRESS"]},
     "00081195": {"vr": "UI", "Value": ["1.2.3.txnuid"]}
   }
   ```
3. **Validation:**
   - Uses `validate_state_transition()` from state machine
   - Transaction UID enforcement per state machine rules
4. **State Transitions:**
   - SCHEDULED → IN PROGRESS (sets transaction UID)
   - IN PROGRESS → COMPLETED (requires matching transaction UID)
   - IN PROGRESS → CANCELED (requires matching transaction UID)
5. **Response:**
   - 200 OK on success
   - 400 Bad Request for invalid transition
   - 409 Conflict if transaction UID doesn't match

### Implementation

```python
@router.put(
    "/v2/workitems/{workitem_uid}/state",
    status_code=200,
    summary="Change workitem state (UPS-RS)",
)
async def change_workitem_state(
    workitem_uid: str,
    request: Request,
    db: AsyncSession = Depends(get_db),
):
    """
    Change workitem state (claim, complete, cancel).

    State machine enforces valid transitions and transaction UID ownership.

    Returns:
    - 200 OK on success
    - 400 Bad Request if invalid transition
    - 404 Not Found if workitem doesn't exist
    - 409 Conflict if transaction UID doesn't match
    """
    payload = await request.json()

    # Get workitem
    result = await db.execute(
        select(Workitem).where(Workitem.sop_instance_uid == workitem_uid)
    )
    workitem = result.scalar_one_or_none()

    if not workitem:
        raise HTTPException(
            status_code=404,
            detail=f"Workitem {workitem_uid} not found"
        )

    # Extract new state
    state_tag = payload.get("00741000", {})
    state_values = state_tag.get("Value", [])
    if not state_values:
        raise HTTPException(
            status_code=400,
            detail="ProcedureStepState (0074,1000) required"
        )
    new_state = state_values[0]

    # Extract transaction UID
    txn_tag = payload.get("00081195", {})
    txn_values = txn_tag.get("Value", [])
    provided_txn_uid = txn_values[0] if txn_values else None

    # Validate state transition
    from app.services.ups_state_machine import validate_state_transition, StateTransitionError

    try:
        validate_state_transition(
            current_state=workitem.procedure_step_state,
            new_state=new_state,
            current_txn_uid=workitem.transaction_uid,
            provided_txn_uid=provided_txn_uid
        )
    except StateTransitionError as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Update state
    workitem.procedure_step_state = new_state

    # Set transaction UID if claiming (SCHEDULED → IN PROGRESS)
    if new_state == "IN PROGRESS" and workitem.transaction_uid is None:
        workitem.transaction_uid = provided_txn_uid

    # Update dataset state
    updated_dataset = workitem.dicom_dataset.copy()
    updated_dataset["00741000"] = {"vr": "CS", "Value": [new_state]}

    # Add transaction UID to dataset if claiming
    if new_state == "IN PROGRESS" and provided_txn_uid:
        updated_dataset["00081195"] = {"vr": "UI", "Value": [provided_txn_uid]}

    workitem.dicom_dataset = updated_dataset

    await db.commit()

    return Response(status_code=200)
```

### Tests

```python
def test_claim_workitem_scheduled_to_in_progress(client: TestClient):
    """Claim SCHEDULED workitem (SCHEDULED → IN PROGRESS)."""
    # Create workitem
    workitem_uid = "1.2.3.4.5"
    # ... create ...

    # Claim workitem
    state_change = {
        "00741000": {"vr": "CS", "Value": ["IN PROGRESS"]},
        "00081195": {"vr": "UI", "Value": ["1.2.3.txn"]}
    }
    response = client.put(f"/v2/workitems/{workitem_uid}/state", json=state_change)

    assert response.status_code == 200


def test_complete_workitem_in_progress_to_completed(client: TestClient):
    """Complete workitem (IN PROGRESS → COMPLETED)."""
    # Create and claim workitem
    # ...

    # Complete workitem
    state_change = {
        "00741000": {"vr": "CS", "Value": ["COMPLETED"]},
        "00081195": {"vr": "UI", "Value": ["1.2.3.txn"]}
    }
    response = client.put(f"/v2/workitems/{workitem_uid}/state", json=state_change)

    assert response.status_code == 200


def test_cannot_complete_with_wrong_txn_uid(client: TestClient):
    """Cannot complete with wrong transaction UID."""
    # Create and claim workitem
    # ...

    # Try to complete with wrong UID
    state_change = {
        "00741000": {"vr": "CS", "Value": ["COMPLETED"]},
        "00081195": {"vr": "UI", "Value": ["wrong-uid"]}
    }
    response = client.put(f"/v2/workitems/{workitem_uid}/state", json=state_change)

    assert response.status_code == 400
```

---

## Task 7: Request Cancellation Endpoint

**Goal:** Implement POST endpoint for requesting workitem cancellation (SCHEDULED only).

**Files:**
- Modify: `app/routers/ups.py`
- Create: `tests/test_ups_cancel.py`

### Requirements

1. **Endpoint:** `POST /v2/workitems/{workitem_uid}/cancelrequest`
2. **Purpose:** Cancel SCHEDULED workitems without transaction UID
3. **Validation:**
   - Only works for SCHEDULED workitems
   - For IN PROGRESS workitems, must use state change endpoint with transaction UID
4. **Behavior:**
   - Changes state from SCHEDULED to CANCELED
   - No transaction UID required (that's the point)
5. **Response:**
   - 202 Accepted on success
   - 400 Bad Request if workitem not SCHEDULED

### Implementation

```python
@router.post(
    "/v2/workitems/{workitem_uid}/cancelrequest",
    status_code=202,
    summary="Request workitem cancellation (UPS-RS)",
)
async def request_cancellation(
    workitem_uid: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Request cancellation of SCHEDULED workitem.

    This endpoint allows canceling SCHEDULED workitems without transaction UID.
    For IN PROGRESS workitems, use state change endpoint with transaction UID.

    Returns:
    - 202 Accepted on success
    - 400 Bad Request if not SCHEDULED
    - 404 Not Found if workitem doesn't exist
    """
    # Get workitem
    result = await db.execute(
        select(Workitem).where(Workitem.sop_instance_uid == workitem_uid)
    )
    workitem = result.scalar_one_or_none()

    if not workitem:
        raise HTTPException(
            status_code=404,
            detail=f"Workitem {workitem_uid} not found"
        )

    # Validate workitem is SCHEDULED
    if workitem.procedure_step_state != "SCHEDULED":
        raise HTTPException(
            status_code=400,
            detail=f"Cannot cancel workitem in {workitem.procedure_step_state} state. "
                   "Use state change endpoint for IN PROGRESS workitems."
        )

    # Cancel workitem
    workitem.procedure_step_state = "CANCELED"

    # Update dataset
    updated_dataset = workitem.dicom_dataset.copy()
    updated_dataset["00741000"] = {"vr": "CS", "Value": ["CANCELED"]}
    workitem.dicom_dataset = updated_dataset

    await db.commit()

    return Response(status_code=202)
```

### Tests

```python
def test_cancel_scheduled_workitem(client: TestClient):
    """Cancel SCHEDULED workitem via cancelrequest."""
    # Create workitem
    workitem_uid = "1.2.3.4.5"
    # ... create ...

    # Cancel workitem
    response = client.post(f"/v2/workitems/{workitem_uid}/cancelrequest")

    assert response.status_code == 202


def test_cannot_cancel_in_progress_workitem(client: TestClient):
    """Cannot use cancelrequest for IN PROGRESS workitem."""
    # Create and claim workitem
    # ...

    # Try to cancel via cancelrequest
    response = client.post(f"/v2/workitems/{workitem_uid}/cancelrequest")

    assert response.status_code == 400
```

---

## Task 8: Search Workitems Endpoint

**Goal:** Implement GET endpoint for searching workitems by various attributes.

**Files:**
- Modify: `app/routers/ups.py`
- Create: `tests/test_ups_search.py`

### Requirements

1. **Endpoint:** `GET /v2/workitems`
2. **Query Parameters:**
   - `PatientID` - Patient identifier
   - `PatientName` - Patient name
   - `ProcedureStepState` - Workitem state
   - `ScheduledProcedureStepStartDateTime` - Scheduled time (range)
   - `limit` - Max results (default 100)
   - `offset` - Pagination offset
3. **Response:**
   - 200 OK with array of workitems (without transaction UIDs)
   - Empty array if no matches
4. **Behavior:**
   - Similar to QIDO-RS search
   - Returns DICOM JSON datasets
   - Transaction UIDs never included

### Implementation

```python
@router.get(
    "/v2/workitems",
    summary="Search workitems (UPS-RS)",
)
async def search_workitems(
    PatientID: str | None = Query(default=None),
    PatientName: str | None = Query(default=None),
    ProcedureStepState: str | None = Query(default=None),
    limit: int = Query(default=100, ge=1, le=1000),
    offset: int = Query(default=0, ge=0),
    db: AsyncSession = Depends(get_db),
):
    """
    Search for workitems.

    Query parameters:
    - PatientID: Filter by patient identifier
    - PatientName: Filter by patient name
    - ProcedureStepState: Filter by state (SCHEDULED, IN PROGRESS, etc.)
    - limit: Max results (default 100)
    - offset: Pagination offset

    Returns:
    - 200 OK with array of workitems (transaction UIDs removed)
    """
    query = select(Workitem)

    # Apply filters
    if PatientID:
        query = query.where(Workitem.patient_id == PatientID)

    if PatientName:
        query = query.where(Workitem.patient_name.ilike(f"%{PatientName}%"))

    if ProcedureStepState:
        query = query.where(Workitem.procedure_step_state == ProcedureStepState)

    # Apply pagination
    query = query.offset(offset).limit(limit)

    # Execute query
    result = await db.execute(query)
    workitems = result.scalars().all()

    # Format results (remove transaction UIDs)
    results = []
    for workitem in workitems:
        dataset = workitem.dicom_dataset.copy()
        dataset.pop("00081195", None)  # Remove transaction UID
        results.append(dataset)

    return results
```

### Tests

```python
def test_search_workitems_by_patient_id(client: TestClient):
    """Search workitems by patient ID."""
    # Create workitems with different patient IDs
    # ...

    # Search by patient ID
    response = client.get("/v2/workitems", params={"PatientID": "PAT123"})

    assert response.status_code == 200
    results = response.json()
    assert len(results) == 2  # Assuming 2 workitems match


def test_search_workitems_by_state(client: TestClient):
    """Search workitems by state."""
    # Create workitems in different states
    # ...

    # Search by state
    response = client.get("/v2/workitems", params={"ProcedureStepState": "SCHEDULED"})

    assert response.status_code == 200
```

---

## Task 9: Subscription Stubs

**Goal:** Implement subscription endpoints that return 501 Not Implemented.

**Files:**
- Modify: `app/routers/ups.py`
- Create: `tests/test_ups_subscriptions.py`

### Requirements

1. **Endpoints:**
   - `POST /v2/workitems/{workitem_uid}/subscribers/{aet}`
   - `DELETE /v2/workitems/{workitem_uid}/subscribers/{aet}`
   - `POST /v2/workitems/workitems/{workitem_uid}/subscribers/{aet}/suspend`
   - `GET /v2/workitems/subscriptions`
2. **Response:** All return 501 Not Implemented
3. **Purpose:** Azure DICOM Service compatibility (these exist but aren't implemented)

### Implementation

```python
@router.post(
    "/v2/workitems/{workitem_uid}/subscribers/{aet}",
    status_code=501,
    summary="Subscribe to workitem (UPS-RS) - NOT IMPLEMENTED",
)
async def subscribe_to_workitem(workitem_uid: str, aet: str):
    """Subscribe to workitem events - NOT IMPLEMENTED."""
    raise HTTPException(
        status_code=501,
        detail="Subscriptions not implemented in this emulator"
    )


@router.delete(
    "/v2/workitems/{workitem_uid}/subscribers/{aet}",
    status_code=501,
    summary="Unsubscribe from workitem (UPS-RS) - NOT IMPLEMENTED",
)
async def unsubscribe_from_workitem(workitem_uid: str, aet: str):
    """Unsubscribe from workitem events - NOT IMPLEMENTED."""
    raise HTTPException(
        status_code=501,
        detail="Subscriptions not implemented in this emulator"
    )


@router.get(
    "/v2/workitems/subscriptions",
    status_code=501,
    summary="List subscriptions (UPS-RS) - NOT IMPLEMENTED",
)
async def list_subscriptions():
    """List all subscriptions - NOT IMPLEMENTED."""
    raise HTTPException(
        status_code=501,
        detail="Subscriptions not implemented in this emulator"
    )
```

### Tests

```python
def test_subscribe_returns_501(client: TestClient):
    """Subscribe endpoint returns 501."""
    response = client.post("/v2/workitems/1.2.3/subscribers/MYAET")
    assert response.status_code == 501


def test_unsubscribe_returns_501(client: TestClient):
    """Unsubscribe endpoint returns 501."""
    response = client.delete("/v2/workitems/1.2.3/subscribers/MYAET")
    assert response.status_code == 501


def test_list_subscriptions_returns_501(client: TestClient):
    """List subscriptions returns 501."""
    response = client.get("/v2/workitems/subscriptions")
    assert response.status_code == 501
```

---

## Summary

**Phase 5 Tasks 5-9: Complete UPS-RS Implementation**

**What We'll Build:**
- Update workitem endpoint (with transaction UID validation)
- Change state endpoint (state machine enforcement)
- Request cancellation endpoint (SCHEDULED only)
- Search workitems endpoint (QIDO-RS style)
- Subscription stubs (501 Not Implemented)

**Testing:**
- ~20 additional tests for new endpoints
- End-to-end workflow tests
- State machine integration tests

**Files to Create:**
- `tests/test_ups_update.py`
- `tests/test_ups_state.py`
- `tests/test_ups_cancel.py`
- `tests/test_ups_search.py`
- `tests/test_ups_subscriptions.py`

**Files to Modify:**
- `app/routers/ups.py` (add 7 new endpoints)
- `README.md` (document UPS-RS endpoints)
- `smoke_test.py` (add UPS workflow test)

**Estimated Scope:**
- 5 tasks
- ~800 lines of code (endpoints + tests)
- ~20-30 tests total
- Full UPS-RS worklist service implementation
